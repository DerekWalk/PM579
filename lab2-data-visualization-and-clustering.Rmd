---
title: "data visualization and clustering"
author: "ks"
date: "5/13/2019"
output: html_document
---

## Lab 2 - Data Visualization and Clustering

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r Libraries}
if(!require("matlab")){BiocManager::install("matlab")} 
if(!require("Biobase")){BiocManager::install("Biobase")} 
if(!require("ggplot2")){BiocManager::install("ggplot2")}
if(!require("ggjoy")){BiocManager::install("ggjoy")} 
if(!require("dplyr")){BiocManager::install("dplyr")} 
if(!require("scatterplot3d")){install.packges("scatterplot3d")} 
if(!require("matrixStats")){install.packges("matrixStats")} 
library(matlab)
library(Biobase)
library(ggplot2)
library(ggjoy)
library(scatterplot3d)
library(limma)
library(tidyr)
library(tidyverse)
library(dplyr)
library(matrixStats)
```

## Load data set

Let's load the data from JBC (2012).
```{r ReadData}
jbcdir=c("data/JBC 2012")
load(file.path(jbcdir,"jbcdat.rda"))
```


## Boxplots
```{r boxplots, echo=FALSE}
boxplot(jbcdat$E,xlab="Arrays",ylab="log2 intensities",main="Gene Expression")
```

Try using ggplot2:

```{r tidybox, echo=FALSE}

df <- cbind.data.frame(barcode = rownames(jbcdat$targets),t(jbcdat$E))

# The arguments to gather():
# - data: Data object
# - key: Name of new key column (made from names of data columns)
# - value: Name of new value column
# - ...: Names of source columns that contain values
# - factor_key: Treat the new key column as a factor (instead of character vector)

data_long <- gather(df, ilmn_id, value, rownames(jbcdat$E), factor_key=TRUE)

data_long %>% 
  ggplot(aes(x=barcode, y = value)) + geom_boxplot()
```

## Density plot

```{r ggdensity}
plot <- ggplot(data_long, aes(value))
plot + geom_density(aes(fill=factor(barcode)), alpha=0.3) +
  labs(title="Density plot",
       x="log2(exprs)",
       fill="Barcode")
```

These overlap so much it's hard to see the different colors. Let's try stacking the density plots.

```{r Densities, echo=FALSE}
data_long %>% mutate(barcode = reorder(barcode, value, median)) %>%
  ggplot(aes(x=value, y=barcode, height=..density..)) +
  geom_joy(scale=0.85)
```

These all look very similar. That is because the arrays were normalized to have very similar distributions.


## Heatmap of JBC Data Set

We will draw a heatmap after filtering to the 500 most variable features. We choose this simply to match the default in plotMDS(). We use interquartile range, a robust measure of variation. To give features equal weight when clustering samples, we standardize them. We do this also using robust measures of location/variation.

```{r topvargenes}
fiqr <- matrixStats::rowIQRs(jbcdat$E)
top500iqr <- order(fiqr, decreasing = TRUE)[1:500]
```

###Draw Heatmap

First we will assign colors for the annotation/treatment information. Then we will create the heatmap and draw it.

```{r Heatmap}
library(ComplexHeatmap)
library(matlab)

# column heatmap annotation
colha <- ComplexHeatmap::HeatmapAnnotation(df = jbcdat$targets[,c("treatments","hour")],
                          col = list(treatments = c(siNS = "pink", 
                                                   siCBP = "purple",
                                                   sip300 = "orange"),
                                     hour = c('0hr' = "grey",
                                             '16hr' = "lightgreen")
                                     ), 
                          which = "column")
# heatmap
ht <- ComplexHeatmap::Heatmap(jbcdat$E[top500iqr,], column_title = "Samples",
              row_title = "Features",
              name = "log2(Expr)", 
              col = jet.colors(32), 
              top_annotation = colha,
              show_column_names = FALSE,
              show_row_names = FALSE)
draw(ht)
```

In the above figure, the clustering is performed on the log2 expression data. Our labels show that the replicate samples cluster well. Often, we standardize the genes first, so that the genes contribute equally to the sample clustering. 

We did not specify the type of dendrogram, but the software default was to use Euclidean distance, and complete linkage for both rows and columns.

Let's see the above dendrogram in detail.

To specify column distances, dist() takes a data matrix and computes distances between rows. Typically in statistics the rows are the samples (but not for microarray data) so we have to transpose the matrix to do this for the correct dimension.

```{r dendrogram}
genesubset <- jbcdat$E[top500iqr,]
colnames(genesubset)<- jbcdat$targets$type
col.dist <- dist(t(genesubset))  #Euclidean distance is the default
hc <- hclust(col.dist,method="complete")
par(cex=1.2,lwd=2)
plot(hc)
```

We find sip300 at 0 hours has a different gene expression signature than siNS or siCBP at 0 hours.


We can use different metrics for row distances and column distances. Here we will use the correlation metric for genes (actually, 1-correlation), and Euclidean distance for samples. However, first, I'm going to use the standardized gene expression values for my clustering.

```{r standardize}
standardize <- function(x){
  stdx <- (x - rowMedians(x))/rowIQRs(x)
}
jbcstd <- standardize(jbcdat$E)
#genesubset <- jbcstd[top500iqr,]
#colnames(genesubset)<- jbcdat$targets$type
```

Row dissimilarities: Genes are the rows of the matrix, but cor() computes correlations between columns so we must transpose the matrix. Now we make it a distance matrix object using as.dist() takes a matrix of pair-wise distances and makes it a distance function (lower-diagonal matrix). 



```{r heatmap2}
row.dist <- as.dist(1 - cor(t(genesubset)))
col.dist <- dist(t(genesubset),method="euclidean")
htc <- ComplexHeatmap::Heatmap(jbcstd[top500iqr,], 
                              cluster_columns = hclust(col.dist,method="average"),
                              cluster_rows = hclust(row.dist,method="average"),
                              column_title = "Samples",
              row_title = "Features",
              name = "log2(Expr)", 
              col = jet.colors(32), 
              top_annotation = colha,
              show_column_names = FALSE,
              show_row_names = FALSE)
draw(htc)
```

Now let's try clustering columns using correlation metric, and average linkage, and draw it beside the last heatmap for comparison.

```{r heatmap3}
row.dist <- as.dist(1 - cor(t(genesubset)))
col.dist <- as.dist(1 - cor(genesubset))
hta <- ComplexHeatmap::Heatmap(jbcstd[top500iqr,], 
                              cluster_columns = hclust(col.dist,method="average"),
                              cluster_rows = hclust(row.dist,method="average"),
                              column_title = "Samples",
              row_title = "Features",
              col = jet.colors(32), 
              top_annotation = colha,
              show_heatmap_legend = FALSE,
              show_column_names = FALSE,
              show_row_names = FALSE)

draw(htc+hta)
```

The figure is different. What changes do you see?


## 3-D MDS plot

```{r 3dscatterplot, echo=FALSE}
mds <- limma::plotMDS(jbcdat$E,ndim = 3,plot = FALSE)
scatterplot3d(mds[[3]],
              color = unclass(jbcdat$targets$type),pch=16,
              xlab = c("Leading logFC dim 1"),
              ylab = c("Leading logFC dim 2"),
              zlab = c("Leading logFC dim 3"),
              main = c("MDS plot for JBC Data Set"),
              zlim = c(-.4,2))
legend("topright",inset = c(0.05,0.1),
       levels(jbcdat$targets$type),
       col = 1:6, bty = "n", pch = 16, ncol = 2)
```

## Cluster analysis using K-means

Kmeans uses a random number generator to generate starting values for the algorithm. In order to reproduce our results later we have to set the seed for the random number generator using the set.seed() command.

```{r kmeans}
library(stats)
set.seed(46)
km4 <- kmeans(t(genesubset),4)
table(km4$cluster,jbcdat$targets$type)
```

The treatments were not perfectly separated. Let's retrieve the within group sum of squares.

```{r kmeans stats}
km4$withinss
sum(km4$withinss)
```

Now try 25 random starts and pick the best solution (minimum WSS)

```{r kmeansMultStart}
kmx <- kmeans(t(genesubset),centers = 4,nstart = 25)
kmx$withinss
sum(kmx$withinss)
table(kmx$cluster,jbcdat$targets$type)
```

From picking the best solution from multiple starts (25) we are able to separate the samples perfectly by treatment.

## Partitioning around Medoids (PAM)
```{r pam}
library(cluster)
p4=pam(t(genesubset),4)
table(p4$cluster,jbcdat$targets$type)
```

# Silhouette plot
```{r silhouette}
silpam4=silhouette(p4)
```

```{r silplot, echo=FALSE}
plot(silpam4)
```

Let's check how many groups the data support.
```{r nclust}
sw <- rep(NA,7)
for (i in 1:7) {
  pm <- pam(t(genesubset),i+1)
  sw[i] <- summary(pm)$silinfo$avg.width
  }
plot(2:8,sw,xlab="Number of Clusters",
     ylab="Average Silhouette Width",type="l")
```

The Silhouette plot maximizes at 3 groups so let's run it again using 3 groups.

```{r pam3}
p3 <- pam(t(genesubset),3)
table(p3$cluster,jbcdat$targets$type)
summary(p3)$silinfo$avg.width
```

The two sip300 samples (0h, 16h) are most different from the rest, but similar to each other.

## Draw heatmap using PAM cluster order for samples
```{r pamorder}
okp3 <- order(p3$cluster)
ogenesubset<- genesubset[,okp3]
row.dist <- as.dist(1 - cor(t(ogenesubset)))
```

Plot heatmap with columns fixed by order of PAM results the default is to scale the rows if symm = FALSE (default), o.w. none.

```{r plotHeat} 
hmp.dist <- heatmap(ogenesubset,labRow = NA, labCol = NA, Colv = NA,
          Rowv = as.dendrogram(hclust(row.dist,method="average")), 
          ColSideColors = as.character(p3$cluster[okp3]),
          xlab = "",ylab = "",col = jet.colors(32))
```

##  Show PAM clusters (by colors) using MDS
```{r plotMDS3}
limma::plotMDS(jbcdat$E,labels = jbcdat$targets$trt_time_rep, 
        col = as.character(p3$cluster))
```

```{r sessionInfo}
sessionInfo()
```